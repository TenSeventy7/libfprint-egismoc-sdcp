/*
 * FpiSdcpDevice - Secure Device Connection Protocol (SDCP) supported FpDevice
 * Copyright (C) 2025 Joshua Grisham <josh@joshuagrisham.com>
 *
 * This library is free software; you can redistribute it and/or
 * modify it under the terms of the GNU Lesser General Public
 * License as published by the Free Software Foundation; either
 * version 2.1 of the License, or (at your option) any later version.
 *
 * This library is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
 * Lesser General Public License for more details.
 *
 * You should have received a copy of the GNU Lesser General Public
 * License along with this library; if not, write to the Free Software
 * Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA 02110-1301 USA
 */

#define FP_COMPONENT "sdcp_device"

#include "fpi-log.h"
#include "fpi-sdcp-device-private.h"

#include <openssl/core_names.h>
#include <openssl/ecdh.h>
#include <openssl/evp.h>
#include <openssl/kdf.h>
#include <openssl/param_build.h>
#include <openssl/rand.h>
#include <openssl/x509.h>

/**
 * SECTION: fpi-sdcp-device
 * @title: Internal FpiSdcpDevice
 * @short_description: Internal FpDevice with support for Microsoft's Secure
 *   Device Connection Protocol (SDCP)
 *
 * This is a base internal class for devices implementing Microsoft's <ulink
 * url="https://github.com/microsoft/SecureDeviceConnectionProtocol/wiki/Secure-Device-Connection-Protocol">
 * Secure Device Connection Protocol</ulink> (SDCP). This is an internal-only
 * device type, providing just a thin wrapper over the normal #FpDevice type as
 * well as some additional helper functions for building the various payloads
 * that are required when interacting with devices that require SDCP.
 *
 * This API is solely intended for drivers. It is purely internal and neither
 * API nor ABI stable. Externally, the device will look and behave just like any
 * other normal #FpDevice.
 *
 * Developers wishing to use this driver type will need to adhere to the
 * following guidance:
 *
 * - Driver implementations should inherit the `FPI_TYPE_SDCP_DEVICE` type, but
 *   will otherwise need to implement the desired entry points of a standard
 *   #FpDevice and utilize all of the normal `fpi_device_*` functions like would
 *   be done with any other #FpDevice.
 *
 * - Some additional SDCP-specific configuration properties are also available
 *   and can be set in the #FpiSdcpDeviceClass used by each driver.
 *
 * - Prior to performing any enroll, verify, or identify actions, the driver
 *   will need to send a `Connect` command to the device and then perform a
 *   verification of the `ConnectResponse`.
 *
 * - The format of the `Connect` command (as with any other commands sent to the
 *   USB device) will be a device- and vendor-specific implementation, but it
 *   will need to include the `host_public_key` and `host_random` generated from
 *   the #FpiSdcpDevice as part of the payload.
 *   - `host_public_key` should be fetched using the function
 *     fpi_sdcp_get_host_public_key()
 *   - `host_random` should be fetched using the function
 *     fpi_sdcp_get_host_random()
 *   - These functions will take care of intializing the internal host keys
 *     whenever necessary; driver developers do not need to worry about this
 *
 * - The `ConnectResponse` received back from the device should then be verified
 *   using the function fpi_sdcp_derive_keys_and_verify_connect() or one of its
 *   variants. This function will handle deriving all of the internal key
 *   exchanges and secrets needed for generating and validating all other
 *   SDCP-related payloads. Depending on the vendor implementation, it might be
 *   necessary for the driver to implement parsing logic to extract and provide
 *   all of the individual fields of the `ConnectResponse` to this function.
 *
 * - The driver can check if the connection is already established prior to
 *   connecting by using the function fpi_sdcp_device_is_connected().
 *
 * - `Reconnect` commands can also be sent to the device by providing a new
 *   `reconnect_random`, which can be generated by fpi_sdcp_generate_random().
 *   Support and even need for using this command seems to vary widely by vendor
 *   and specific implementation. Also keep in mind that performing a
 *   `Reconnect` and the subsequent verification of the `ReconnectResponse` with
 *   fpi_sdcp_verify_reconnect() will not have any impact on the internal keys
 *   and secrets used, but might be required in cases where the device would
 *   otherwise begin to reject payloads from the driver.
 *
 * - According to the SDCP specification, it should be possible to initiate and
 *   verify a new `Connect` at any time, which would then generate new internal
 *   keys and secrets, but support for this might also vary by specifc vendor
 *   and device implementation.
 *
 * - New Enrollment IDs should be generated using the function
 *   fpi_sdcp_generate_enrollment_id() and sent to the device as part of the
 *   vendor- and device-specific `Enroll` command implementation. Upon
 *   successful enrollment, this `enrollment_id` should be saved with the
 *   #FpPrint's data so that subsequent actions can be matched to the correct
 *   print using this identifier. Refer to the SDCP specification and your own
 *   device's implementation requirements for more information on the exact
 *   sequence of events that should be implemented for the enrollment process.
 *
 * - `Identify` commands sent to the device are expected to include an
 *   `identify_nonce`, which can be generated with the help of function
 *   fpi_sdcp_generate_random(). On success, the device should respond using
 *   SDCP's `AuthorizedIdentity` format, which includes the `enrollment_id` of
 *   the identified match as well as a security digest. This response can be
 *   verified using the function fpi_sdcp_verify_authorized_identity(), but
 *   support for correctly generating the digest may vary by device and vendor
 *   implementation; the important thing is that the matched `enrollment_id`
 *   can be successfully retrieved from the device.
 *
 * - As the `fprintd` service will sleep often, there is a caching mechanism
 *   built into #FpiSdcpDevice to serialize the connected SDCP claim to disk
 *   once the connection is established, and read this cached claim back from
 *   disk when the service starts again. This is to prevent the need to
 *   re-establish a new connection every time that `fprintd` wakes again, as
 *   this can be a somewhat resource-intensive operation and might not even be
 *   supported by all devices. The functions fpi_sdcp_device_is_connected() and
 *   fpi_sdcp_device_can_reconnect() can be utilized at any time to determine if
 *   establishing a new connection or reconnecting may be required.
 *
 * - Cached SDCP claims will be invalidated and ignored if 1) they were from a
 *   previous system boot, or 2) the
 *   #FpiSdcpDeviceClass.claim_expiration_seconds configured by the driver
 *   implementation has elapsed, at which point fpi_sdcp_device_is_connected()
 *   will return %FALSE and a new connection should be established. The rule of
 *   thumb is to just check fpi_sdcp_device_is_connected() (then optionally
 *   fpi_sdcp_device_can_reconnect()) every time before performing an enroll,
 *   verify, or identify action, and reconnect or establish a new connection
 *   when necessary.
 */

G_DEFINE_ABSTRACT_TYPE_WITH_PRIVATE (FpiSdcpDevice, fpi_sdcp_device, FP_TYPE_DEVICE)

/*********************************************************/

static EVP_PKEY *
sdcp_get_pkey (const guchar *private_key_bytes, const guchar *public_key_bytes)
{
  BIGNUM *private_key_bn;
  EC_GROUP *group;
  EC_POINT *public_key_point;
  OSSL_PARAM_BLD *param_bld;
  OSSL_PARAM *params;
  EVP_PKEY_CTX *ctx;
  EVP_PKEY *key = NULL;

  guchar public_key_buf[SDCP_PUBLIC_KEY_SIZE];

  g_assert ((private_key_bytes && !public_key_bytes) || (!private_key_bytes && public_key_bytes));

  param_bld = OSSL_PARAM_BLD_new ();
  OSSL_PARAM_BLD_push_utf8_string (param_bld, OSSL_PKEY_PARAM_GROUP_NAME,
    SDCP_OPENSSL_CURVE_GROUP_NAME, sizeof (SDCP_OPENSSL_CURVE_GROUP_NAME));
    
  if (private_key_bytes)
  {
    /* import private key as a BIGNUM */
    private_key_bn = BN_bin2bn (private_key_bytes, SDCP_PRIVATE_KEY_SIZE, NULL);

    OSSL_PARAM_BLD_push_BN (param_bld, OSSL_PKEY_PARAM_PRIV_KEY,
      private_key_bn);

    /* set up public key based on imported private_key_bn */
    group = EC_GROUP_new_by_curve_name (SDCP_OPENSSL_CURVE_GROUP_NID);
    public_key_point = EC_POINT_new (group);
    EC_POINT_mul (group, public_key_point, private_key_bn, NULL, NULL, NULL);
    EC_POINT_point2oct (group, public_key_point, POINT_CONVERSION_UNCOMPRESSED,
      public_key_buf, sizeof (public_key_buf), NULL);
    EC_POINT_free (public_key_point);
    EC_GROUP_free (group);

    OSSL_PARAM_BLD_push_octet_string (param_bld, OSSL_PKEY_PARAM_PUB_KEY,
      public_key_buf, sizeof (public_key_buf));
  } else {
    /* set up public key with provided bytes */
    OSSL_PARAM_BLD_push_octet_string (param_bld, OSSL_PKEY_PARAM_PUB_KEY,
      public_key_bytes, SDCP_PUBLIC_KEY_SIZE);
  }

  params = OSSL_PARAM_BLD_to_param (param_bld);
  OSSL_PARAM_BLD_free (param_bld);
  
  /* import key from above params */
  ctx = EVP_PKEY_CTX_new_from_name (NULL, "EC", NULL);
  EVP_PKEY_fromdata_init (ctx);
  EVP_PKEY_fromdata (ctx, &key, EVP_PKEY_KEYPAIR, params);
  EVP_PKEY_CTX_free (ctx);
  g_free (params);
  if (private_key_bytes)
    BN_free (private_key_bn);

  /* check the resulting key */
  ctx = EVP_PKEY_CTX_new (key, NULL);
  EVP_PKEY_check (ctx);
  EVP_PKEY_CTX_free (ctx);

  return g_steal_pointer (&key);
}

gboolean
fpi_sdcp_set_host_keys (FpiSdcpDevice *device,
                        const guchar  *private_key_bytes,
                        const guchar  *random_bytes)
{
  FpiSdcpDevicePrivate *priv = fpi_sdcp_device_get_instance_private (device);

  EVP_PKEY *key = NULL;
  BIGNUM *private_key_bn = NULL;
  guchar *private_key;
  int private_key_len = 0;
  guchar public_key[SDCP_PUBLIC_KEY_SIZE];
  gsize public_key_len = 0;
  guchar *random;

  if (priv->host_key)
    EVP_PKEY_free (priv->host_key);

  /* invalidate is_connected as we are replacing the host key */
  priv->is_connected = FALSE;

  if (private_key_bytes)
    key = sdcp_get_pkey (private_key_bytes, NULL);
  else
    key = EVP_EC_gen (SDCP_OPENSSL_CURVE_NAME);

  /* get private_key from the key */
  if (!EVP_PKEY_get_bn_param(key, OSSL_PKEY_PARAM_PRIV_KEY, &private_key_bn))
    {
      g_error ("Failed getting private key");
      return FALSE;
    }
  private_key_len = BN_num_bytes (private_key_bn);
  g_assert (private_key_len == SDCP_PRIVATE_KEY_SIZE);
  private_key = g_malloc0 (private_key_len);
  if (!BN_bn2bin (private_key_bn, private_key))
    {
      g_error ("Failed getting private key bytes");
      return FALSE;
    }
  BN_clear_free (private_key_bn);

  /* if private_key_bytes were provided then ensure the new pk matches */
  if (private_key_bytes)
    g_assert_cmpmem (private_key_bytes, SDCP_PRIVATE_KEY_SIZE,
                     private_key, SDCP_PRIVATE_KEY_SIZE);

  /* get public_key from the key */
  if (!EVP_PKEY_get_octet_string_param (key, OSSL_PKEY_PARAM_PUB_KEY,
      public_key, SDCP_PUBLIC_KEY_SIZE, &public_key_len))
    {
      g_error ("Failed getting public key");
      return FALSE;
    }
  g_assert (public_key_len == SDCP_PUBLIC_KEY_SIZE);

  /* set private member values */
  priv->host_key = g_steal_pointer (&key);

  memcpy (priv->host_private_key,
          private_key,
          SDCP_PRIVATE_KEY_SIZE);
  g_free (private_key);

  memcpy (priv->host_public_key,
          public_key,
          SDCP_PUBLIC_KEY_SIZE);

  /* set provided random_bytes, otherise generate new */
  if (random_bytes)
    {
      memcpy (priv->host_random,
              random_bytes,
              SDCP_RANDOM_SIZE);
    }
  else
    {
      random = fpi_sdcp_generate_random ();
      memcpy (priv->host_random,
              random,
              SDCP_RANDOM_SIZE);
      g_free (random);
    }

  return TRUE;
}

static int
sdcp_get_kbkdf_secret (const guchar *key, gsize key_len,
                       const guchar *label, gsize label_len,
                       const guchar *context, gsize context_len,
                       guchar **secret, gsize secret_len)
{
  EVP_KDF *kdf;
  EVP_KDF_CTX *kdf_ctx;
  guchar key_buf[SDCP_MAX_SECRET_SIZE];
  g_autofree guchar *out = g_malloc0 (secret_len);

  OSSL_PARAM params[7];
  int i = 0;

  /* For some reason setting key only seems to work with local array (not a pointer) */
  memcpy (key_buf, key, key_len);

  params[i++] = OSSL_PARAM_construct_utf8_string (OSSL_KDF_PARAM_MODE, (gchar *) "counter", 0);
  params[i++] = OSSL_PARAM_construct_utf8_string (OSSL_KDF_PARAM_MAC, (gchar *) "HMAC", 0);
  params[i++] = OSSL_PARAM_construct_utf8_string (OSSL_KDF_PARAM_DIGEST, (gchar *) "SHA2-256", 0);
  params[i++] = OSSL_PARAM_construct_octet_string (OSSL_KDF_PARAM_KEY, key_buf, key_len);

  if (label)
    params[i++] = OSSL_PARAM_construct_octet_string (OSSL_KDF_PARAM_SALT, (guchar *) label, label_len);

  if (context)
    params[i++] = OSSL_PARAM_construct_octet_string (OSSL_KDF_PARAM_INFO, (guchar *) context, context_len);

  params[i++] = OSSL_PARAM_construct_end ();

  kdf = EVP_KDF_fetch (NULL, "KBKDF", NULL);
  kdf_ctx = EVP_KDF_CTX_new (kdf);

  if (EVP_KDF_derive (kdf_ctx, out, secret_len, params) <= 0) {
    fp_err ("Failure deriving KBKDF secret");
    return -1;
  }

  EVP_KDF_CTX_free (kdf_ctx);
  EVP_KDF_free (kdf);

  if (!secret || !(*secret))
    g_free (*secret);

  *secret = g_steal_pointer (&out);
  return secret_len;
}

static int
sdcp_derive_key_agreement (FpiSdcpDevice *device,
                           const guchar  *device_firmware_public_key)
{
  FpiSdcpDevicePrivate *priv = fpi_sdcp_device_get_instance_private (device);

  EVP_PKEY_CTX *ctx = NULL;
  EVP_PKEY *device_fw_key = NULL;
  g_autofree guchar *key_agreement;
  gsize key_agreement_len = 0;

  ctx = EVP_PKEY_CTX_new_from_pkey (NULL, priv->host_key, NULL);
  device_fw_key = sdcp_get_pkey (NULL, device_firmware_public_key);

  EVP_PKEY_derive_init (ctx);
  EVP_PKEY_derive_set_peer (ctx, device_fw_key);

  /* Get the size by passing NULL as the buffer */
  EVP_PKEY_derive (ctx, NULL, &key_agreement_len);

  g_assert (key_agreement_len == SDCP_KEY_AGREEMENT_SIZE);

  /* Then get the derived secret using the fetched size */
  key_agreement = g_malloc0 (key_agreement_len);
  EVP_PKEY_derive (ctx, key_agreement, &key_agreement_len);
  EVP_PKEY_CTX_free (ctx);
  EVP_PKEY_free (device_fw_key);

  memcpy (priv->key_agreement, key_agreement, key_agreement_len);

  return (int) key_agreement_len;
}

static int
sdcp_derive_master_secret (FpiSdcpDevice *device, const guchar *device_random)
{
  FpiSdcpDevicePrivate *priv = fpi_sdcp_device_get_instance_private (device);

  guchar context[SDCP_RANDOM_SIZE * 2];
  g_autofree guchar *master_secret;
  int len = 0;

  /* context is concatenation of host_random and device_random */
  memcpy (context, priv->host_random, SDCP_RANDOM_SIZE);
  memcpy (context + SDCP_RANDOM_SIZE, device_random, SDCP_RANDOM_SIZE);

  len = sdcp_get_kbkdf_secret (priv->key_agreement, SDCP_KEY_AGREEMENT_SIZE,
                               (guchar *) "master secret", strlen ("master secret"),
                               context, sizeof (context),
                               &master_secret, SDCP_MASTER_SECRET_SIZE);

  g_assert (len == SDCP_MASTER_SECRET_SIZE);

  memcpy (priv->master_secret, master_secret, SDCP_MASTER_SECRET_SIZE);

  return len;
}

static int
sdcp_derive_application_keys (FpiSdcpDevice *device)
{
  FpiSdcpDevicePrivate *priv = fpi_sdcp_device_get_instance_private (device);

  g_autofree guchar *application_keys;
  int len = 0;

  len = sdcp_get_kbkdf_secret (priv->master_secret, SDCP_MASTER_SECRET_SIZE,
                               (guchar *) "application keys", strlen ("application keys"),
                               NULL, 0, /* no context for application keys per SDCP */
                               &application_keys, SDCP_APPLICATION_SECRET_SIZE
                               + SDCP_APPLICATION_SYMMETRIC_KEY_SIZE);

  g_assert (len == SDCP_APPLICATION_SECRET_SIZE
                   + SDCP_APPLICATION_SYMMETRIC_KEY_SIZE);

  memcpy (priv->application_secret, application_keys, SDCP_APPLICATION_SECRET_SIZE);
  memcpy (priv->application_symmetric_key, application_keys + SDCP_APPLICATION_SECRET_SIZE,
          SDCP_APPLICATION_SYMMETRIC_KEY_SIZE);

  return len;
}

/*********************************************************/

#define FPI_SDCP_CLAIM_VARIANT_FORMAT "(ayayayayayayayxs)"
#define FPI_SDCP_CLAIM_GET_VARIANT_FORMAT "(@ay@ay@ay@ay@ay@ay@ayxs)"
#define KERNEL_BOOT_ID_PATH "/proc/sys/kernel/random/boot_id"

static char *boot_id = NULL;

static const gchar *
sdcp_get_boot_id (void)
{
  g_autofree gchar *kernel_boot_id = NULL;

  /* if possible, read the boot_id exposed by the kernel */
  if (boot_id == NULL)
    if (g_file_get_contents (KERNEL_BOOT_ID_PATH, &kernel_boot_id, NULL, NULL))
      boot_id = g_strdup (kernel_boot_id);

  /*
   * if that fails, try to use a "boot time"-like value, converted to seconds
   * unfortunately monotonic_time can lose ticks during suspend which will occasionally
   * lead to mismatches when using this logic
   * (which will lead to new connections even if they are not always needed)
   */
  if (boot_id == NULL)
    boot_id = g_strdup_printf ("%ld",
                               (g_get_real_time () - g_get_monotonic_time ()) / G_USEC_PER_SEC);

  return boot_id;
}

/*
 * fpi_sdcp_device_get_cached_claim_path uses a bit of shameless stealing from
 * file_storage.c in fprintd; maybe some of this duplication can be moved out at
 * some point?
 */

static char *storage_path = NULL;

static const gchar *
fpi_sdcp_device_get_cached_claim_path (FpiSdcpDevice *self)
{
  FpiSdcpDevicePrivate *priv = fpi_sdcp_device_get_instance_private (self);
  FpDevice *device = FP_DEVICE (self);

  const gchar *base_path = NULL;
  g_autofree gchar *path = NULL;
  g_autofree gchar *driver = NULL;
  g_autofree gchar *device_id = NULL;
  gchar *claim_storage_path = NULL;

  if (priv->claim_storage_path != NULL)
    return priv->claim_storage_path;

  if (storage_path == NULL)
    {
      /* set by systemd >= 240 to an absolute path
       * taking into account the StateDirectory
       * unit file setting */
      base_path = g_getenv ("STATE_DIRECTORY");
      if (base_path != NULL)
        {
          /* If multiple directories are set, then in the environment variable
          * the paths are concatenated with colon (":"). */
          if (strchr (base_path, ':'))
            {
              g_auto(GStrv) elems = NULL;
              elems = g_strsplit (base_path, ":", -1);
              storage_path = g_strdup (elems[0]);
            }
          else if (*base_path)
            {
              storage_path = g_strdup (base_path);
            }
        }
    }

  if (storage_path == NULL)
    storage_path = g_build_filename (g_get_tmp_dir (), ".libfprint", NULL);

  driver = g_strdup (fp_device_get_driver (device));
  device_id = g_strdup (fp_device_get_device_id (device));
  path = g_build_filename (storage_path, driver, device_id, NULL);

  if (g_mkdir_with_parents (path, 0700) < 0)
    {
      fp_dbg ("Failed to create SDCP cache directory \"%s\"", path);
      return NULL;
    }

  claim_storage_path = g_build_filename (path, "sdcp-claim", NULL);
  priv->claim_storage_path = g_steal_pointer (&claim_storage_path);

  return priv->claim_storage_path;
}

void
fpi_sdcp_device_delete_cached_claim (FpiSdcpDevice *self)
{
  const gchar *path = NULL;
  g_autoptr(GFile) file = NULL;
  g_autoptr(GError) err = NULL;

  path = fpi_sdcp_device_get_cached_claim_path (self);

  if (!g_file_test (path, G_FILE_TEST_EXISTS | G_FILE_TEST_IS_REGULAR))
    return;

  file = g_file_new_for_path (path);
  
  g_file_delete (file, NULL, &err);
  if (err)
    {
      fp_dbg ("Error trying to delete SDCP claim cache file (\"%s\"): %s",
              path, err->message);
      return;
    }

  fp_dbg ("Deleted SDCP claim cache file \"%s\"", path);
}

static void
fpi_sdcp_device_cache_connected_claim (FpiSdcpDevice *self)
{
  FpiSdcpDevicePrivate *priv = fpi_sdcp_device_get_instance_private (self);

  g_autoptr(GError) err = NULL;
  g_autoptr(GVariant) claim = NULL;
  g_autoptr(GVariant) private_key_var = NULL;
  g_autoptr(GVariant) public_key_var = NULL;
  g_autoptr(GVariant) random_var = NULL;
  g_autoptr(GVariant) key_agreement_var = NULL;
  g_autoptr(GVariant) master_secret_var = NULL;
  g_autoptr(GVariant) app_secret_var = NULL;
  g_autoptr(GVariant) app_symmetric_key_var = NULL;
  g_autofree guchar *data = NULL;
  gsize data_len;
  const gchar *path = NULL;

  g_assert (priv->is_connected);

  private_key_var = g_variant_new_fixed_array (G_VARIANT_TYPE_BYTE,
                                               priv->host_private_key,
                                               SDCP_PRIVATE_KEY_SIZE,
                                               sizeof (guchar));

  public_key_var = g_variant_new_fixed_array (G_VARIANT_TYPE_BYTE,
                                              priv->host_public_key,
                                              SDCP_PUBLIC_KEY_SIZE,
                                              sizeof (guchar));

  random_var = g_variant_new_fixed_array (G_VARIANT_TYPE_BYTE,
                                          priv->host_random,
                                          SDCP_RANDOM_SIZE,
                                          sizeof (guchar));

  key_agreement_var = g_variant_new_fixed_array (G_VARIANT_TYPE_BYTE,
                                                 priv->key_agreement,
                                                 SDCP_KEY_AGREEMENT_SIZE,
                                                 sizeof (guchar));

  master_secret_var = g_variant_new_fixed_array (G_VARIANT_TYPE_BYTE,
                                                 priv->master_secret,
                                                 SDCP_MASTER_SECRET_SIZE,
                                                 sizeof (guchar));

  app_secret_var = g_variant_new_fixed_array (G_VARIANT_TYPE_BYTE,
                                              priv->application_secret,
                                              SDCP_APPLICATION_SECRET_SIZE,
                                              sizeof (guchar));

  app_symmetric_key_var = g_variant_new_fixed_array (G_VARIANT_TYPE_BYTE,
                                                     priv->application_symmetric_key,
                                                     SDCP_APPLICATION_SYMMETRIC_KEY_SIZE,
                                                     sizeof (guchar));

  claim = g_variant_new (FPI_SDCP_CLAIM_GET_VARIANT_FORMAT,
                         g_variant_ref_sink (private_key_var),
                         g_variant_ref_sink (public_key_var),
                         g_variant_ref_sink (random_var),
                         g_variant_ref_sink (key_agreement_var),
                         g_variant_ref_sink (master_secret_var),
                         g_variant_ref_sink (app_secret_var),
                         g_variant_ref_sink (app_symmetric_key_var),
                         priv->claim_connected_time,
                         sdcp_get_boot_id ());

#if (G_BYTE_ORDER == G_BIG_ENDIAN)
  GVariant *tmp;
  tmp = g_variant_byteswap (claim);
  g_variant_unref (claim);
  claim = tmp;
#endif

  data_len = g_variant_get_size (claim);
  data = g_malloc0 (data_len);
  g_variant_store (claim, data);

  path = fpi_sdcp_device_get_cached_claim_path (self);
  g_file_set_contents (path, (const gchar *) data, data_len, &err);
  if (err)
    {
      fp_err ("Error when writing SDCP claim cache to file (\"%s\"): %s",
              path, err->message);
    }

  fp_dbg ("Cached SDCP claim to file \"%s\"", path);
}

static gboolean
sdcp_get_iter_bytes_value (GVariantIter *iter, gsize len, guchar **out)
{
  guchar *result = g_malloc0 (len);
  guchar tmp;
  int i = 0;
  while (g_variant_iter_loop (iter, "y", &tmp))
    {
      if (i >= len)
        {
          fp_warn ("GVariantIter bytes length is greater than desired output length.");
          g_free (result);
          return FALSE;
        }
      result[i++] = tmp;
    }
  *out = g_steal_pointer (&result);
  return TRUE;
}

static GVariant *
fpi_sdcp_device_get_cached_claim_variant (FpiSdcpDevice *self)
{
  const gchar *path = NULL;
  g_autoptr(GError) err = NULL;
  guchar *file_data = NULL;
  gsize file_data_len;
  g_autoptr(GVariant) variant_raw = NULL;
  GVariant *variant;

  path = fpi_sdcp_device_get_cached_claim_path (self);

  if (!g_file_test (path, G_FILE_TEST_EXISTS | G_FILE_TEST_IS_REGULAR))
    {
      fp_dbg ("Cached claim file \"%s\" does not exist.", path);
      return NULL;
    }

  if (!g_file_get_contents (path, (gchar **) &file_data, &file_data_len, &err))
    {
      fp_dbg ("Failed to read cached claim file \"%s\"", path);
      goto delete_and_exit;
    }
  if (err)
    {
      fp_dbg ("Error when attempting to read cached claim file (\"%s\"): %s",
               path, err->message);
      goto delete_and_exit;
    }

  variant_raw = g_variant_new_from_data (G_VARIANT_TYPE (FPI_SDCP_CLAIM_VARIANT_FORMAT),
                                         file_data, file_data_len,
                                         FALSE, g_free, file_data);
  if (!variant_raw)
    {
      fp_dbg ("Failed to get GVariant from claim file data (\"%s\")", path);
      goto delete_and_exit;
    }

#if (G_BYTE_ORDER == G_BIG_ENDIAN)
  variant = g_variant_byteswap (variant_raw);
#else
  variant = g_variant_get_normal_form (variant_raw);
#endif

  fp_dbg ("Got cached SDCP claim from file \"%s\"", path);

  return g_steal_pointer (&variant);

delete_and_exit:
  fpi_sdcp_device_delete_cached_claim (self);
  return NULL;
}

static gboolean
sdcp_is_claim_expired (FpiSdcpDevice *device)
{
  FpiSdcpDevicePrivate *priv = fpi_sdcp_device_get_instance_private (device);
  gint64 expires_at;

  if (priv->claim_expiration_seconds < 0)
    return FALSE;

  expires_at = priv->claim_connected_time
               + ((gint64) priv->claim_expiration_seconds * G_USEC_PER_SEC);

  if (expires_at < g_get_monotonic_time ())
    {
      fp_dbg ("SDCP Claim is expired (older than %d seconds).",
              priv->claim_expiration_seconds);
      return TRUE;
    }

  return FALSE;
}

static gboolean
fpi_sdcp_device_init_claim (FpiSdcpDevice *self)
{
  FpiSdcpDevicePrivate *priv = fpi_sdcp_device_get_instance_private (self);

  g_autoptr(GVariant) cached = NULL;
  g_autoptr(GVariantIter) private_key_iter = NULL;
  g_autofree guchar *private_key = NULL;
  g_autoptr(GVariantIter) public_key_iter= NULL;
  g_autofree guchar *public_key = NULL;
  g_autoptr(GVariantIter) random_iter= NULL;
  g_autofree guchar *random = NULL;
  g_autoptr(GVariantIter) key_agreement_iter= NULL;
  g_autofree guchar *key_agreement = NULL;
  g_autoptr(GVariantIter) master_secret_iter= NULL;
  g_autofree guchar *master_secret = NULL;
  g_autoptr(GVariantIter) app_secret_iter= NULL;
  g_autofree guchar *app_secret = NULL;
  g_autoptr(GVariantIter) app_symmetric_key_iter= NULL;
  g_autofree guchar *app_symmetric_key = NULL;
  g_autofree gchar *cached_boot_id = NULL;
  gint64 cached_connected_time;
  gboolean read = FALSE;

  cached = fpi_sdcp_device_get_cached_claim_variant (self);

  if (!cached)
    goto generate_new;

  g_variant_get (cached,
                 FPI_SDCP_CLAIM_VARIANT_FORMAT,
                 &private_key_iter,
                 &public_key_iter,
                 &random_iter,
                 &key_agreement_iter,
                 &master_secret_iter,
                 &app_secret_iter,
                 &app_symmetric_key_iter,
                 &cached_connected_time,
                 &cached_boot_id);

  if (!g_str_equal (cached_boot_id, sdcp_get_boot_id ()))
    {
      fp_dbg ("Cached SDCP claim is from previous boot %s and is no longer valid.", cached_boot_id);
      fpi_sdcp_device_delete_cached_claim (self);
      goto generate_new;
    }

  priv->claim_connected_time = cached_connected_time;

  if (sdcp_is_claim_expired (self))
    goto generate_new;

  /* set the private key and random based on stored bytes */
  read = sdcp_get_iter_bytes_value (private_key_iter, SDCP_PRIVATE_KEY_SIZE, &private_key);
  if (!read)
    goto cache_init_failed;

  read = sdcp_get_iter_bytes_value (random_iter, SDCP_RANDOM_SIZE, &random);
  if (!read)
    goto cache_init_failed;

  if (!fpi_sdcp_set_host_keys (self, private_key, random))
    goto cache_init_failed;

  /* ensure the public key of the newly set private key still matches from before */
  read = sdcp_get_iter_bytes_value (public_key_iter, SDCP_PUBLIC_KEY_SIZE, &public_key);
  if (memcmp (priv->host_public_key, public_key, SDCP_PUBLIC_KEY_SIZE) != 0)
    {
      fp_warn ("Public key in cached claim does not match cached private key's public bytes");
      goto cache_init_failed;
    }

  /* set everything else in the claim */

  read = sdcp_get_iter_bytes_value (key_agreement_iter, SDCP_KEY_AGREEMENT_SIZE, &key_agreement);
  if (!read)
    goto cache_init_failed;
  memcpy (priv->key_agreement, key_agreement, SDCP_KEY_AGREEMENT_SIZE);

  read = sdcp_get_iter_bytes_value (master_secret_iter, SDCP_MASTER_SECRET_SIZE, &master_secret);
  if (!read)
    goto cache_init_failed;
  memcpy (priv->master_secret, master_secret, SDCP_MASTER_SECRET_SIZE);

  read = sdcp_get_iter_bytes_value (app_secret_iter, SDCP_APPLICATION_SECRET_SIZE, &app_secret);
  if (!read)
    goto cache_init_failed;
  memcpy (priv->application_secret, app_secret, SDCP_APPLICATION_SECRET_SIZE);

  read = sdcp_get_iter_bytes_value (app_symmetric_key_iter, SDCP_APPLICATION_SYMMETRIC_KEY_SIZE,
                                    &app_symmetric_key);
  if (!read)
    goto cache_init_failed;
  memcpy (priv->application_symmetric_key, app_symmetric_key, SDCP_APPLICATION_SYMMETRIC_KEY_SIZE);

  priv->is_connected = TRUE;

  return TRUE;

cache_init_failed:
  fp_warn ("Failed initializing claim from cached file.");
  fpi_sdcp_device_delete_cached_claim (self);
generate_new:
  fp_dbg ("Generating new SDCP device host keys.");
  return fpi_sdcp_set_host_keys (self, NULL, NULL);
}

/*********************************************************/

/**
 * fpi_sdcp_get_host_public_key:
 * @device: The #FpiSdcpDevice
 *
 * Returns: (transfer full): The public bytes of the #FpiSdcpDevice's ephemeral
 *   host key (`pk_h`) for use when preparing the SDCP `Connect` command payload
 */
guchar *
fpi_sdcp_get_host_public_key (FpiSdcpDevice *device)
{
  FpiSdcpDevicePrivate *priv = fpi_sdcp_device_get_instance_private (device);
  guchar *public_key = g_malloc0 (SDCP_PUBLIC_KEY_SIZE);

  if (!priv->host_key)
    g_assert (fpi_sdcp_device_init_claim (device));

  memcpy (public_key, priv->host_public_key, SDCP_PUBLIC_KEY_SIZE);
  return g_steal_pointer (&public_key);
}

/**
 * fpi_sdcp_get_host_random:
 * @device: The #FpiSdcpDevice
 *
 * Returns: (transfer full): The #FpiSdcpDevice's host random (`r_h`) for use
 *   when preparing the SDCP `Connect` command payload
 */
guchar *
fpi_sdcp_get_host_random (FpiSdcpDevice *device)
{
  FpiSdcpDevicePrivate *priv = fpi_sdcp_device_get_instance_private (device);
  guchar *random = g_malloc0 (SDCP_RANDOM_SIZE);

  if (!priv->host_key)
    g_assert (fpi_sdcp_device_init_claim (device));

  memcpy (random, priv->host_random, SDCP_RANDOM_SIZE);
  return g_steal_pointer (&random);
}

/**
 * fpi_sdcp_derive_keys_and_verify_connect:
 * @device: The #FpiSdcpDevice
 * @connect_response: #FpiSdcpConnectResponse filled with the `ConnectResponse`
 *   received from the device after executing its device- and vendor-specific
 *   implementation of the `Connect` command
 *
 * Processes the @connect_response in order to establish a secure connection
 * channel with the device using the <ulink
 * url="https://github.com/microsoft/SecureDeviceConnectionProtocol/wiki/Secure-Device-Connection-Protocol#bootstrapping-a-secure-channel">
 * process outlined in the SDCP documentation</ulink>:
 *
 * - Performs key agreement
 * - Derives master secret
 * - Derives application keys
 * - Verifies the connection by regenerating and validating the MAC
 *
 * This function (or one of its variants) MUST be executed in order to establish
 * a secure connection with the device BEFORE any enroll or identify/verify
 * commands are sent to the device, as the secrets derived by this function are
 * used when generating and validating all subsequent SDCP-related payloads.
 *
 * Returns: %TRUE when the connection was verified and a claim has been
 *   established, otherwise %FALSE.
 */
gboolean
fpi_sdcp_derive_keys_and_verify_connect (FpiSdcpDevice          *device,
                                         FpiSdcpConnectResponse *connect_response)
{
  FpiSdcpDevicePrivate *priv = fpi_sdcp_device_get_instance_private (device);

  EVP_MD_CTX *sh256_ctx;
  EVP_MD *sha256;
  EVP_MAC *hmac;
  EVP_MAC_CTX *hmac_ctx;
  guchar claim_hash[SDCP_DIGEST_SIZE];
  guint claim_hash_len = 0;
  guchar host_connect_mac[SDCP_DIGEST_SIZE];
  gsize host_connect_mac_len = 0;

  OSSL_PARAM hmac_sha256_params[] = {
    OSSL_PARAM_construct_utf8_string (OSSL_MAC_PARAM_DIGEST, (gchar *) "SHA256", 0),
    OSSL_PARAM_construct_end (),
  };

  /* Ensure we can parse the provided certificate and print its details if dbg is enabled */
  /* TODO: Maybe this is not actually needed? but nice to have at the beginning anyway... */

  X509 *cert;
  BIO *bio = BIO_new (BIO_s_mem ());
  BUF_MEM *bio_mem;

  const guchar *cert_buf_ptr = connect_response->model_certificate;
  cert = d2i_X509 (NULL, &cert_buf_ptr, connect_response->model_certificate_len);
  g_assert (cert);

  X509_print (bio, cert);
  BIO_get_mem_ptr (bio, &bio_mem);
  fp_dbg ("SDCP Device reported the following model certificate:\n%.*s\n",
    (int) bio_mem->length, bio_mem->data);
  BIO_free (bio);
  X509_free (cert);

  g_assert (sdcp_derive_key_agreement (device, connect_response->firmware_public_key));
  g_assert (sdcp_derive_master_secret (device, connect_response->device_random));
  g_assert (sdcp_derive_application_keys (device));

  sh256_ctx = EVP_MD_CTX_create ();
  sha256 = EVP_MD_fetch (NULL, "SHA256", NULL);
  EVP_DigestInit_ex (sh256_ctx, sha256, NULL);
  EVP_DigestUpdate (sh256_ctx, connect_response->model_certificate,
                    connect_response->model_certificate_len);
  EVP_DigestUpdate (sh256_ctx, connect_response->device_public_key, SDCP_PUBLIC_KEY_SIZE);
  EVP_DigestUpdate (sh256_ctx, connect_response->firmware_public_key, SDCP_PUBLIC_KEY_SIZE);
  EVP_DigestUpdate (sh256_ctx, connect_response->firmware_hash, SDCP_DIGEST_SIZE);
  EVP_DigestUpdate (sh256_ctx, connect_response->model_signature, SDCP_SIGNATURE_SIZE);
  EVP_DigestUpdate (sh256_ctx, connect_response->device_signature, SDCP_SIGNATURE_SIZE);
  EVP_DigestFinal_ex (sh256_ctx, claim_hash, &claim_hash_len);
  EVP_MD_CTX_free (sh256_ctx);
  EVP_MD_free (sha256);

  g_assert (claim_hash_len == SDCP_DIGEST_SIZE);

  hmac = EVP_MAC_fetch (NULL, "hmac", NULL);
  hmac_ctx = EVP_MAC_CTX_new (hmac);
  EVP_MAC_init (hmac_ctx, priv->application_secret, SDCP_DIGEST_SIZE, hmac_sha256_params);
  EVP_MAC_update (hmac_ctx, (guchar *) "connect", sizeof ("connect"));
  EVP_MAC_update (hmac_ctx, claim_hash, SDCP_DIGEST_SIZE);
  EVP_MAC_final (hmac_ctx, host_connect_mac, &host_connect_mac_len, SDCP_DIGEST_SIZE);
  EVP_MAC_CTX_free (hmac_ctx);
  EVP_MAC_free (hmac);

  g_assert (host_connect_mac_len == SDCP_DIGEST_SIZE);

  if (memcmp (connect_response->mac, host_connect_mac,
    SDCP_DIGEST_SIZE) == 0) {
    fp_info ("SDCP ConnectResponse verified successfully.");
    priv->is_connected = TRUE;
    priv->claim_connected_time = g_get_monotonic_time ();
    fpi_sdcp_device_cache_connected_claim (device);
    return TRUE;
  } else {
    fp_err ("SDCP ConnectResponse verification failed.");
    return FALSE;
  }
}

/**
 * fpi_sdcp_derive_keys_and_verify_connect_buf:
 * @device: The #FpiSdcpDevice
 * @connect_response_buf: Buffer that contains a `ConnectResponse` which exactly
 *   matches the specification
 * @connect_response_buf_len: Length of @connect_response_buf
 *
 * Variant of fpi_sdcp_derive_keys_and_verify_connect() that can be used when
 * the provided @connect_response_buf exactly matches the `ConnectResponse`
 * payload specified in the SDCP documentation (`r_d`, `c`, `m`).
 *
 * Returns: %TRUE when the connection was verified and a claim has been
 *   established, otherwise %FALSE.
 */
gboolean
fpi_sdcp_derive_keys_and_verify_connect_buf (FpiSdcpDevice *device,
                                             const guchar  *connect_response_buf,
                                             const gsize    connect_response_buf_len)
{
  g_autoptr(FpiSdcpConnectResponse) response = g_new0 (FpiSdcpConnectResponse, 1);
  int pos = 0;

  /* buf len should be at least larger than all required parts (plus a cert) */
  g_assert (connect_response_buf_len > SDCP_RANDOM_SIZE
                                       + SDCP_PUBLIC_KEY_SIZE
                                       + SDCP_PUBLIC_KEY_SIZE
                                       + SDCP_DIGEST_SIZE
                                       + SDCP_SIGNATURE_SIZE
                                       + SDCP_SIGNATURE_SIZE
                                       + SDCP_DIGEST_SIZE);

  /* r_d */
  memcpy (response->device_random, connect_response_buf + pos, SDCP_RANDOM_SIZE);
  pos += SDCP_RANDOM_SIZE;

  /* get cert_m length from its' TLV */
  response->model_certificate_len = fpi_sdcp_get_cert_length_from_buf (connect_response_buf
                                                                       + SDCP_RANDOM_SIZE);

  /* cert_m */
  response->model_certificate = g_malloc0 (response->model_certificate_len);
  memcpy (response->model_certificate, connect_response_buf + pos, response->model_certificate_len);
  pos += response->model_certificate_len;

  /* pk_d */
  memcpy (response->device_public_key, connect_response_buf + pos, SDCP_PUBLIC_KEY_SIZE);
  pos += SDCP_PUBLIC_KEY_SIZE;

  /* pk_f */
  memcpy (response->firmware_public_key, connect_response_buf + pos, SDCP_PUBLIC_KEY_SIZE);
  pos += SDCP_PUBLIC_KEY_SIZE;

  /* h_f */
  memcpy (response->firmware_hash, connect_response_buf + pos, SDCP_DIGEST_SIZE);
  pos += SDCP_DIGEST_SIZE;

  /* s_m */
  memcpy (response->model_signature, connect_response_buf + pos, SDCP_SIGNATURE_SIZE);
  pos += SDCP_SIGNATURE_SIZE;

  /* s_d */
  memcpy (response->device_signature, connect_response_buf + pos, SDCP_SIGNATURE_SIZE);
  pos += SDCP_SIGNATURE_SIZE;

  /* m */
  memcpy (response->mac, connect_response_buf + pos, SDCP_DIGEST_SIZE);
  pos += SDCP_DIGEST_SIZE;

  return fpi_sdcp_derive_keys_and_verify_connect (device, response);
}

/**
 * fpi_sdcp_derive_keys_and_verify_connect_ex:
 * @device: The #FpiSdcpDevice
 * @device_random: Random bytes generated by the device (`r_d`)
 * @model_certificate: Microsoft-issued per-model certificate encoded in x509
 *   ASN.1 DER format (`cert_m`)
 * @model_certificate_len: Length of @model_certificate
 * @device_public_key: The per-device ECDSA public key (`pk_d`)
 * @firmware_public_key: The ephemeral public key generated by the device
 *   firmware (`pk_f`)
 * @firmware_hash: Hash of the firmware and firmware public key (`h_f`)
 * @model_signature: Device public key signed by the model key (`s_m`)
 * @device_signature: Firmware hash and public key signed by the device private
 *   key (`s_d`)
 * @mac: MAC of the claim hash (`m`)
 *
 * Variant of fpi_sdcp_derive_keys_and_verify_connect() that can be used in
 * cases where the device- and vendor-specific implementation of the
 * `ConnectResponse` may require additional parsing and it is easier to provide
 * each member of the response as a separate parameter.
 *
 * Returns: %TRUE when the connection was verified and a claim has been
 *   established, otherwise %FALSE.
 */
gboolean
fpi_sdcp_derive_keys_and_verify_connect_ex (FpiSdcpDevice *device,
                                            const guchar  *device_random,
                                            const guchar  *model_certificate, 
                                            const gsize    model_certificate_len, 
                                            const guchar  *device_public_key, 
                                            const guchar  *firmware_public_key, 
                                            const guchar  *firmware_hash, 
                                            const guchar  *model_signature, 
                                            const guchar  *device_signature, 
                                            const guchar  *mac)
{
  g_autoptr(FpiSdcpConnectResponse) response = g_new0 (FpiSdcpConnectResponse, 1);

  response->model_certificate = g_malloc0 (model_certificate_len);

  memcpy (response->device_random, device_random, SDCP_RANDOM_SIZE);
  memcpy (response->model_certificate, model_certificate, model_certificate_len);
  response->model_certificate_len = model_certificate_len;
  memcpy (response->device_public_key, device_public_key, SDCP_PUBLIC_KEY_SIZE);
  memcpy (response->firmware_public_key, firmware_public_key, SDCP_PUBLIC_KEY_SIZE);
  memcpy (response->firmware_hash, firmware_hash, SDCP_DIGEST_SIZE);
  memcpy (response->model_signature, model_signature, SDCP_SIGNATURE_SIZE);
  memcpy (response->device_signature, device_signature, SDCP_SIGNATURE_SIZE);
  memcpy (response->mac, mac, SDCP_DIGEST_SIZE);

  return fpi_sdcp_derive_keys_and_verify_connect (device, response);
}

/**
 * fpi_sdcp_device_is_connected:
 * @device: The #FpiSdcpDevice
 *
 * Helper function that can be used to determine if the driver should establish
 * a secure connection with the device (by executing the device's SDCP `Connect`
 * command and processing the `ConnectResponse` using
 * fpi_sdcp_derive_keys_and_verify_connect()) prior to executing any enroll,
 * verify, or identify commands on the device.
 *
 * Returns: %TRUE if a valid connection claim already exists for the device, or
 *   %FALSE if there is no existing claim or the claim has expired according to
 *   the #FpiSdcpDeviceClass.claim_expiration_seconds set by the driver
 */
gboolean
fpi_sdcp_device_is_connected (FpiSdcpDevice *device)
{
  FpiSdcpDevicePrivate *priv = fpi_sdcp_device_get_instance_private (device);

  if (!priv->host_key)
    g_assert (fpi_sdcp_device_init_claim (device));

  if (!priv->is_connected)
    return FALSE;

  return !sdcp_is_claim_expired (device);
}

/**
 * fpi_sdcp_device_can_reconnect:
 * @device: The #FpiSdcpDevice
 *
 * Helper function that can be used to determine if the driver should be able to
 * execute an SDCP `Reconnect` when fpi_sdcp_device_is_connected() has returned
 * %FALSE.
 *
 * Returns: %TRUE if #FpiSdcpDeviceClass.supports_reconnect and there is an
 *   existing but expired connection claim for the device, otherwise %FALSE
 */
gboolean
fpi_sdcp_device_can_reconnect (FpiSdcpDevice *device)
{
  FpiSdcpDevicePrivate *priv = fpi_sdcp_device_get_instance_private (device);

  if (!priv->supports_reconnect)
    return FALSE;

  if (!priv->is_connected)
    return FALSE;

  return sdcp_is_claim_expired (device);
}

/**
 * fpi_sdcp_verify_reconnect:
 * @device: The #FpiSdcpDevice
 * @host_reconnect_random: Reconnect random (`r_h`) that was sent to device when
 *   executing its device- and vendor-specific implemenation of the `Reconnect`
 *   command
 * @device_reconnect_mac: Reconnect MAC (`m`) received from the device after
 *   executing its device- and vendor-specific implemenation of the `Reconnect`
 *   command
 *
 * Verifies a successful reconnection by regenerating and validating the
 * reconnect MAC from the existing claim's derived secrets and the provided
 * @host_reconnect_random, using the <ulink
 * url="https://github.com/microsoft/SecureDeviceConnectionProtocol/wiki/Secure-Device-Connection-Protocol#reusing-an-existing-connection">
 * Reconnect process outlined in the SDCP documentation</ulink>.
 *
 * If %FALSE is returned then the reconnection was not successful, in which
 * case a full `Connect` sequence should then be executed to establish a new
 * secure connection channel.
 *
 * Returns: %TRUE when the reconnection was verified, otherwise %FALSE.
 */
gboolean
fpi_sdcp_verify_reconnect (FpiSdcpDevice *device,
                           const guchar  *host_reconnect_random,
                           const guchar  *device_reconnect_mac)
{
  FpiSdcpDevicePrivate *priv = fpi_sdcp_device_get_instance_private (device);

  EVP_MAC *hmac;
  EVP_MAC_CTX *hmac_ctx;
  guchar host_reconnect_mac[SDCP_DIGEST_SIZE];
  gsize host_reconnect_mac_len = 0;

  OSSL_PARAM hmac_sha256_params[] = {
    OSSL_PARAM_construct_utf8_string (OSSL_MAC_PARAM_DIGEST, (gchar *) "SHA256", 0),
    OSSL_PARAM_construct_end (),
  };

  /* reconnect checks private member to allow reconnecting after claim expired */
  g_assert (priv->is_connected);

  hmac = EVP_MAC_fetch (NULL, "hmac", NULL);
  hmac_ctx = EVP_MAC_CTX_new (hmac);
  EVP_MAC_init (hmac_ctx, priv->application_secret, SDCP_APPLICATION_SECRET_SIZE,
                hmac_sha256_params);
  EVP_MAC_update (hmac_ctx, (guchar *) "reconnect", sizeof ("reconnect"));
  EVP_MAC_update (hmac_ctx, host_reconnect_random, SDCP_DIGEST_SIZE);
  EVP_MAC_final (hmac_ctx, host_reconnect_mac, &host_reconnect_mac_len, SDCP_DIGEST_SIZE);
  EVP_MAC_CTX_free (hmac_ctx);
  EVP_MAC_free (hmac);

  g_assert (host_reconnect_mac_len == SDCP_DIGEST_SIZE);

  if (memcmp (device_reconnect_mac, host_reconnect_mac, SDCP_DIGEST_SIZE) == 0) {
    fp_info ("SDCP ReconnectResponse verified successfully.");
    priv->is_connected = TRUE;
    priv->claim_connected_time = g_get_monotonic_time ();
    fpi_sdcp_device_cache_connected_claim (device);
    return TRUE;
  } else {
    fp_err ("SDCP ReconnectResponse verification failed");
    /* TODO: Should this set priv->is_connected to FALSE? */
    return FALSE;
  }
}

/**
 * fpi_sdcp_verify_authorized_identity:
 * @device: The #FpiSdcpDevice
 * @host_identify_nonce: Identification nonce (`n`) that was sent to device when
 *   executing its device- and vendor-specific implemenation of the `Identify`
 *   command
 * @device_enrollment_id: Enrollment ID (`id`) received from the device's
 *   template database to indicate which print was identified upon a successful
 *   execution of its `Identify` command
 * @device_identify_mac: Identify MAC (`m`) received from the device
 *
 * Validates the MAC generated by the device can be regenerated by the host
 * using the existing claim's derived secrets and the provided
 * @host_identify_nonce, in accordance with the <ulink
 * url="https://github.com/microsoft/SecureDeviceConnectionProtocol/wiki/Secure-Device-Connection-Protocol#identification">
 * Identification process outlined in the SDCP documentation</ulink>.
 *
 * Returns: %TRUE when the Identify MAC was verified, otherwise %FALSE.
 */
gboolean
fpi_sdcp_verify_authorized_identity (FpiSdcpDevice *device,
                                     const guchar  *host_identify_nonce,
                                     const guchar  *device_enrollment_id,
                                     const guchar  *device_identify_mac)
{
  FpiSdcpDevicePrivate *priv = fpi_sdcp_device_get_instance_private (device);

  EVP_MAC *hmac;
  EVP_MAC_CTX *hmac_ctx;
  guchar host_identify_mac[SDCP_DIGEST_SIZE];
  gsize host_identify_mac_len = 0;

  OSSL_PARAM hmac_sha256_params[] = {
    OSSL_PARAM_construct_utf8_string (OSSL_MAC_PARAM_DIGEST, (gchar *) "SHA256", 0),
    OSSL_PARAM_construct_end (),
  };

  g_assert (fpi_sdcp_device_is_connected (device));

  hmac = EVP_MAC_fetch (NULL, "hmac", NULL);
  hmac_ctx = EVP_MAC_CTX_new (hmac);
  EVP_MAC_init (hmac_ctx, priv->application_secret, SDCP_APPLICATION_SECRET_SIZE,
                hmac_sha256_params);
  EVP_MAC_update (hmac_ctx, (guchar *) "identify", sizeof ("identify"));
  EVP_MAC_update (hmac_ctx, host_identify_nonce, SDCP_NONCE_SIZE);
  EVP_MAC_update (hmac_ctx, device_enrollment_id, SDCP_ENROLLMENT_ID_SIZE);
  EVP_MAC_final (hmac_ctx, host_identify_mac, &host_identify_mac_len, SDCP_DIGEST_SIZE);
  EVP_MAC_CTX_free (hmac_ctx);
  EVP_MAC_free (hmac);

  g_assert (host_identify_mac_len == SDCP_DIGEST_SIZE);

  if (memcmp (device_identify_mac, host_identify_mac, SDCP_DIGEST_SIZE) == 0) {
    fp_info ("SDCP AuthorizedIdentity verified successfully.");
    return TRUE;
  } else {
    fp_err ("SDCP AuthorizedIdentity verification failed.");
    return FALSE;
  }
}

/**
 * fpi_sdcp_generate_random:
 *
 * Generates a new secure random of length %SDCP_RANDOM_SIZE that can be used
 * when building the command payload for executing the device's `Enroll` and
 * `Identify` commands
 *
 * Returns: (transfer full): A new secure random of length %SDCP_RANDOM_SIZE
 */
guchar *
fpi_sdcp_generate_random (void)
{
  guchar buf[SDCP_RANDOM_SIZE];
  guchar *out = g_malloc0 (SDCP_RANDOM_SIZE);

  RAND_bytes (buf, SDCP_RANDOM_SIZE);
  memcpy (out, buf, SDCP_RANDOM_SIZE);

  return g_steal_pointer (&out);
}

/**
 * fpi_sdcp_generate_enrollment_id:
 * @device: The #FpiSdcpDevice
 * @device_nonce: Enrollment nonce (`n`) that was received from the device when
 *   executing its device- and vendor-specific implemenation of the
 *   `EnrollBegin` command
 *
 * Generates a new Enrollment ID of length %SDCP_ENROLLMENT_ID_SIZE from the
 * existing claim's derived secrets and the provided @device_nonce.
 *
 * This Enrollment ID must be used when building the command payload for
 * executing the device's `EnrollCommit` command, in accordance with the <ulink
 * url="https://github.com/microsoft/SecureDeviceConnectionProtocol/wiki/Secure-Device-Connection-Protocol#enrollment">
 * Enrollment process outlined in the SDCP documentation</ulink>.
 *
 * Returns: (transfer full): A new Enrollment ID of length
 *   %SDCP_ENROLLMENT_ID_SIZE
 */
guchar *
fpi_sdcp_generate_enrollment_id (FpiSdcpDevice *device,
                                 const guchar  *device_nonce)
{
  FpiSdcpDevicePrivate *priv = fpi_sdcp_device_get_instance_private (device);

  EVP_MAC *hmac;
  EVP_MAC_CTX *hmac_ctx;
  g_autofree guchar *out = g_malloc0 (SDCP_ENROLLMENT_ID_SIZE);
  gsize out_len;

  OSSL_PARAM hmac_sha256_params[] = {
    OSSL_PARAM_construct_utf8_string (OSSL_MAC_PARAM_DIGEST, (gchar *) "SHA256", 0),
    OSSL_PARAM_construct_end (),
  };

  g_assert (fpi_sdcp_device_is_connected (device));

  hmac = EVP_MAC_fetch (NULL, "hmac", NULL);
  hmac_ctx = EVP_MAC_CTX_new (hmac);
  EVP_MAC_init (hmac_ctx, priv->application_secret, SDCP_APPLICATION_SECRET_SIZE,
                hmac_sha256_params);
  EVP_MAC_update (hmac_ctx, (guchar *) "enroll", sizeof ("enroll"));
  EVP_MAC_update (hmac_ctx, device_nonce, SDCP_NONCE_SIZE);
  EVP_MAC_final (hmac_ctx, out, &out_len, SDCP_ENROLLMENT_ID_SIZE);
  EVP_MAC_CTX_free (hmac_ctx);
  EVP_MAC_free (hmac);

  g_assert (out_len == SDCP_ENROLLMENT_ID_SIZE);
  
  return g_steal_pointer (&out);
}

/**
 * fpi_sdcp_get_cert_length_from_buf:
 * @buf: Buffer that starts with (but can be longer than) a DER-encoded ASN.1
 *   certificate
 *
 * Helper function that inspects the TLV of @buf to extract and return the
 * length of the certificate that @buf starts with.
 *
 * Returns: The length of the certificate from the start of @buf
 */
int
fpi_sdcp_get_cert_length_from_buf (const guchar *buf)
{
  guchar value_buf[4] = { 0 };
  guchar *value_buf_ptr = value_buf;
  int buf_value_length = 0;
  int result = 0;

  /*
   * buf is assumed to be a DER-encoded ASN.1 certificate of unknown length
   * buf[0] should be a tag field (0x30 = SEQUENCE)
   * buf[1] should be 0x80 + length of length value (e.g. 0x82 means length value should be next 0x2 bytes long)
   * buf+2 to buf[1]-0x80 should be the actual length of our cert payload, which is what we are looking for!
   */

  g_assert (buf && buf[0] && buf[0] == 0x30 && buf[1] && buf[1] > 0x80);

  buf_value_length = buf[1] - 0x80;

  /*
   * we can just copy the bytes into a 4-byte buffer (to match int) in big endian and then take each
   * byte one-by-one to build the resulting int value
   */
  memcpy (value_buf_ptr + (sizeof (value_buf) - buf_value_length),
          buf + 2,
          buf_value_length);

  result = value_buf[0] << 24 | value_buf[1] << 16 | value_buf[2] << 8 | value_buf[3];

  /* plus add the number of bytes of the TLV prefix itself to get the total length */
  result += 2 + buf_value_length;

  return result;
}

/**
 * fpi_sdcp_connect_response_free:
 * @connect_response: The #FpiSdcpConnectResponse
 *
 * Frees the @connect_response. Will be called automatically if the
 * #FpiSdcpConnectResponse is declared using `g_autoptr`.
 */
void
fpi_sdcp_connect_response_free (FpiSdcpConnectResponse *connect_response)
{
  g_clear_pointer (&connect_response->model_certificate, g_free);
  g_clear_pointer (&connect_response, g_free);
}

/*********************************************************/

static void
fpi_sdcp_device_finalize (GObject *object)
{
  FpiSdcpDevice *self = (FpiSdcpDevice *) object;
  FpiSdcpDevicePrivate *priv = fpi_sdcp_device_get_instance_private (self);

  g_clear_pointer (&priv->host_key, EVP_PKEY_free);
  g_clear_pointer (&priv->claim_storage_path, g_free);

  G_OBJECT_CLASS (fpi_sdcp_device_parent_class)->finalize (object);
}

static void
fpi_sdcp_device_constructed (GObject *object)
{
  FpiSdcpDevice *self = (FpiSdcpDevice *) object;
  FpiSdcpDeviceClass *cls = FPI_SDCP_DEVICE_GET_CLASS (self);
  FpiSdcpDevicePrivate *priv = fpi_sdcp_device_get_instance_private (self);

  if (cls->claim_expiration_seconds == 0)
    cls->claim_expiration_seconds = 86400;

  priv->claim_expiration_seconds = cls->claim_expiration_seconds;
  priv->supports_reconnect = cls->supports_reconnect;

  G_OBJECT_CLASS (fpi_sdcp_device_parent_class)->constructed (object);
}

static void
fpi_sdcp_device_init (FpiSdcpDevice *self)
{
}

static void
fpi_sdcp_device_class_init (FpiSdcpDeviceClass *klass)
{
  GObjectClass *object_class = G_OBJECT_CLASS (klass);

  object_class->constructed = fpi_sdcp_device_constructed;
  object_class->finalize = fpi_sdcp_device_finalize;
}
