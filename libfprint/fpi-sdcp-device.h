/*
 * FpiSdcpDevice - Secure Device Connection Protocol (SDCP) supported FpDevice
 * Copyright (C) 2025 Joshua Grisham <josh@joshuagrisham.com>
 *
 * This library is free software; you can redistribute it and/or
 * modify it under the terms of the GNU Lesser General Public
 * License as published by the Free Software Foundation; either
 * version 2.1 of the License, or (at your option) any later version.
 *
 * This library is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
 * Lesser General Public License for more details.
 *
 * You should have received a copy of the GNU Lesser General Public
 * License along with this library; if not, write to the Free Software
 * Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA 02110-1301 USA
 */

#pragma once

#include "fpi-device.h"

#include <openssl/obj_mac.h>

#define FP_SDCP_OPENSSL_CURVE_NAME        "P-256"
#define FP_SDCP_OPENSSL_CURVE_GROUP_NID   NID_X9_62_prime256v1
#define FP_SDCP_OPENSSL_CURVE_GROUP_NAME  SN_X9_62_prime256v1

#define FP_SDCP_RANDOM_SIZE                     32
#define FP_SDCP_DIGEST_SIZE                     32
#define FP_SDCP_NONCE_SIZE                      32
#define FP_SDCP_PRIVATE_KEY_SIZE                32
#define FP_SDCP_PUBLIC_KEY_SIZE                 65
#define FP_SDCP_SIGNATURE_SIZE                  64
#define FP_SDCP_KEY_AGREEMENT_SIZE              32
#define FP_SDCP_MASTER_SECRET_SIZE              32
#define FP_SDCP_APPLICATION_SECRET_SIZE         32
#define FP_SDCP_APPLICATION_SYMMETRIC_KEY_SIZE  32
#define FP_SDCP_ENROLLMENT_ID_SIZE              32
#define FP_SDCP_MAX_SECRET_SIZE                 64

/*********************************************************/

G_BEGIN_DECLS

#define FPI_TYPE_SDCP_DEVICE (fpi_sdcp_device_get_type ())
G_DECLARE_DERIVABLE_TYPE (FpiSdcpDevice, fpi_sdcp_device, FPI, SDCP_DEVICE, FpDevice)

struct _FpiSdcpDeviceClass
{
  /*< private >*/
  FpDeviceClass parent_class;

  /*< public >*/
  /* Boolean to indicate if the device supports the SDCP Reconnect process */
  gboolean supports_reconnect;

  /* Time in seconds before a connected SDCP claim will be invalidated;
   * defaults to 86400 or can be set to -1 to disable expiration. */
  gint32 claim_expiration_seconds;
};

G_END_DECLS

/*********************************************************/

/**
 * FpiSdcpConnectResponse:
 * @device_random: Random bytes generated by the device (r_d)
 * @model_certificate: Microsoft-issued per-model certificate encoded in x509
 *   ASN.1 DER format (cert_m)
 * @model_certificate_length: Length of model_certificate
 * @device_public_key: The per-device ECDSA public key (pk_d)
 * @firmware_public_key: The ephemeral public key generated by the device
 *   firmware (pk_f)
 * @firmware_hash: Hash of the firmware and firmware public key (h_f)
 * @model_signature: Device public key signed by the model key (s_m)
 * @device_signature: Firmware hash and public key signed by the device private
 *   key (s_d)
 * @mac: MAC of the claim hash (m)
 *
 * TODO description.
 */
struct _FpiSdcpConnectResponse
{
  guchar device_random[FP_SDCP_RANDOM_SIZE]; /* r_d */
  guchar *model_certificate; /* cert_m */
  gsize model_certificate_len;
  guchar device_public_key[FP_SDCP_PUBLIC_KEY_SIZE]; /* pk_d */
  guchar firmware_public_key[FP_SDCP_PUBLIC_KEY_SIZE]; /* pk_f */
  guchar firmware_hash[FP_SDCP_DIGEST_SIZE]; /* h_f */
  guchar model_signature[FP_SDCP_SIGNATURE_SIZE]; /* s_m */
  guchar device_signature[FP_SDCP_SIGNATURE_SIZE]; /* s_d */
  guchar mac[FP_SDCP_DIGEST_SIZE]; /* m */
};
typedef struct _FpiSdcpConnectResponse FpiSdcpConnectResponse;

/*********************************************************/

void fpi_sdcp_connect_response_free (FpiSdcpConnectResponse *connect_response);
G_DEFINE_AUTOPTR_CLEANUP_FUNC (FpiSdcpConnectResponse, fpi_sdcp_connect_response_free)

/* TODO: DOCUMENT THAT THIS IS MOSTLY FOR UNIT TESTING ?? */
gboolean fpi_sdcp_set_host_keys (FpiSdcpDevice *device,
                                 const guchar  *host_private_key_bytes,
                                 const guchar  *host_random);

/* TODO: DOCUMENT THAT THIS MUST BE FREED! */
guchar *fpi_sdcp_get_host_public_key (FpiSdcpDevice *device);

/* TODO: DOCUMENT THAT THIS MUST BE FREED! */
guchar *fpi_sdcp_get_host_random (FpiSdcpDevice *device);

gboolean fpi_sdcp_derive_keys_and_verify_connect (FpiSdcpDevice          *device,
                                                  FpiSdcpConnectResponse *device_connect_response);

gboolean fpi_sdcp_derive_keys_and_verify_connect_buf (FpiSdcpDevice *device,
                                                      const guchar  *device_connect_response_buf,
                                                      const gsize    device_connect_response_buf_len);

gboolean fpi_sdcp_derive_keys_and_verify_connect_ex (FpiSdcpDevice *device,
                                                     const guchar  *device_random,
                                                     const guchar  *model_certificate, 
                                                     const gsize    model_certificate_len, 
                                                     const guchar  *device_public_key, 
                                                     const guchar  *firmware_public_key, 
                                                     const guchar  *firmware_hash, 
                                                     const guchar  *model_signature, 
                                                     const guchar  *device_signature, 
                                                     const guchar  *device_connect_mac);

gboolean fpi_sdcp_device_is_connected (FpiSdcpDevice *device);

gboolean fpi_sdcp_device_can_reconnect (FpiSdcpDevice *device);

gboolean fpi_sdcp_verify_reconnect (FpiSdcpDevice *device,
                                    const guchar  *host_reconnect_random,
                                    const guchar  *device_reconnect_mac);

gboolean fpi_sdcp_verify_authorized_identity (FpiSdcpDevice *device,
                                              const guchar  *host_identify_nonce,
                                              const guchar  *device_id,
                                              const guchar  *device_mac);

/* TODO: DOCUMENT THAT THIS MUST BE FREED! */
guchar *fpi_sdcp_generate_random (void);

/* TODO: DOCUMENT THAT THIS MUST BE FREED! */
guchar *fpi_sdcp_generate_enrollment_id (FpiSdcpDevice *device,
                                         const guchar  *device_nonce);

int fpi_sdcp_get_cert_length_from_buf (const guchar *buf);

void fpi_sdcp_device_delete_cached_claim (FpiSdcpDevice *self);
