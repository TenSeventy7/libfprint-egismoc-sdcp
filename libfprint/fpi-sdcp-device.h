/*
 * FpiSdcpDevice - Secure Device Connection Protocol (SDCP) supported FpDevice
 * Copyright (C) 2025 Joshua Grisham <josh@joshuagrisham.com>
 *
 * This library is free software; you can redistribute it and/or
 * modify it under the terms of the GNU Lesser General Public
 * License as published by the Free Software Foundation; either
 * version 2.1 of the License, or (at your option) any later version.
 *
 * This library is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
 * Lesser General Public License for more details.
 *
 * You should have received a copy of the GNU Lesser General Public
 * License along with this library; if not, write to the Free Software
 * Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA 02110-1301 USA
 */

#pragma once

#include "fpi-device.h"

#include <openssl/obj_mac.h>

#define SDCP_OPENSSL_CURVE_NAME        "P-256"
#define SDCP_OPENSSL_CURVE_GROUP_NID   NID_X9_62_prime256v1
#define SDCP_OPENSSL_CURVE_GROUP_NAME  SN_X9_62_prime256v1

#define SDCP_RANDOM_SIZE                     32
#define SDCP_DIGEST_SIZE                     32
#define SDCP_NONCE_SIZE                      32
#define SDCP_PRIVATE_KEY_SIZE                32
#define SDCP_PUBLIC_KEY_SIZE                 65
#define SDCP_SIGNATURE_SIZE                  64
#define SDCP_KEY_AGREEMENT_SIZE              32
#define SDCP_MASTER_SECRET_SIZE              32
#define SDCP_APPLICATION_SECRET_SIZE         32
#define SDCP_APPLICATION_SYMMETRIC_KEY_SIZE  32
#define SDCP_ENROLLMENT_ID_SIZE              32
#define SDCP_MAX_SECRET_SIZE                 64

G_BEGIN_DECLS

#define FPI_TYPE_SDCP_DEVICE (fpi_sdcp_device_get_type ())
G_DECLARE_DERIVABLE_TYPE (FpiSdcpDevice, fpi_sdcp_device, FPI, SDCP_DEVICE, FpDevice)

/**
 * FpiSdcpDeviceClass:
 * @supports_reconnect: Boolean to indicate if the device supports the <ulink
 *   url="https://github.com/microsoft/SecureDeviceConnectionProtocol/wiki/Secure-Device-Connection-Protocol#reusing-an-existing-connection">
 *   SDCP Reconnect process</ulink>
 * @claim_expiration_seconds: Time in seconds before a connected SDCP claim will
 *   be invalidated; defaults to 86400 or can be set to -1 to disable expiration.
 *
 * Additional configuration properties to control the behavior of an #FpiSdcpDevice.
 * 
 * Drivers using #FpiSdcpDevice must always implement all of the entry points in
 * a standard #FpiDevice, and can optionally set these additional properties to
 * control behavior of the device's SDCP functionality if needed.
 *
 * This API is solely intended for drivers. It is purely internal and neither
 * API nor ABI stable.
 */
struct _FpiSdcpDeviceClass
{
  /*< private >*/
  FpDeviceClass parent_class;

  /*< public >*/
  gboolean supports_reconnect;
  gint32 claim_expiration_seconds;
};

/**
 * FpiSdcpConnectResponse:
 * @device_random: Random bytes generated by the device (`r_d`)
 * @model_certificate: Microsoft-issued per-model certificate encoded in x509
 *   ASN.1 DER format (`cert_m`)
 * @model_certificate_length: Length of @model_certificate
 * @device_public_key: The per-device ECDSA public key (`pk_d`)
 * @firmware_public_key: The ephemeral public key generated by the device
 *   firmware (`pk_f`)
 * @firmware_hash: Hash of the firmware and firmware public key (`h_f`)
 * @model_signature: Device public key signed by the model key (`s_m`)
 * @device_signature: Firmware hash and public key signed by the device private
 *   key (`s_d`)
 * @mac: MAC of the claim hash (`m`)
 *
 * Struct to represent the values of the `ConnectResponse` received from the
 * vendor-specific `Connect` command, for use with
 * fpi_sdcp_derive_keys_and_verify_connect().
 * 
 * Must be declared with `g_autoptr` or freed manually with
 * fpi_sdcp_connect_response_free().
 */
struct _FpiSdcpConnectResponse
{
  guchar device_random[SDCP_RANDOM_SIZE];            /* r_d    */
  guchar *model_certificate;                         /* cert_m */
  gsize model_certificate_len;
  guchar device_public_key[SDCP_PUBLIC_KEY_SIZE];    /* pk_d   */
  guchar firmware_public_key[SDCP_PUBLIC_KEY_SIZE];  /* pk_f   */
  guchar firmware_hash[SDCP_DIGEST_SIZE];            /* h_f    */
  guchar model_signature[SDCP_SIGNATURE_SIZE];       /* s_m    */
  guchar device_signature[SDCP_SIGNATURE_SIZE];      /* s_d    */
  guchar mac[SDCP_DIGEST_SIZE];                      /* m      */
};
typedef struct _FpiSdcpConnectResponse FpiSdcpConnectResponse;

guchar *fpi_sdcp_get_host_public_key (FpiSdcpDevice *device);

guchar *fpi_sdcp_get_host_random (FpiSdcpDevice *device);

gboolean fpi_sdcp_derive_keys_and_verify_connect (FpiSdcpDevice          *device,
                                                  FpiSdcpConnectResponse *device_connect_response);

gboolean fpi_sdcp_derive_keys_and_verify_connect_buf (FpiSdcpDevice *device,
                                                      const guchar  *device_connect_response_buf,
                                                      const gsize    device_connect_response_buf_len);

gboolean fpi_sdcp_derive_keys_and_verify_connect_ex (FpiSdcpDevice *device,
                                                     const guchar  *device_random,
                                                     const guchar  *model_certificate, 
                                                     const gsize    model_certificate_len, 
                                                     const guchar  *device_public_key, 
                                                     const guchar  *firmware_public_key, 
                                                     const guchar  *firmware_hash, 
                                                     const guchar  *model_signature, 
                                                     const guchar  *device_signature, 
                                                     const guchar  *mac);

gboolean fpi_sdcp_device_is_connected (FpiSdcpDevice *device);

gboolean fpi_sdcp_device_can_reconnect (FpiSdcpDevice *device);

gboolean fpi_sdcp_verify_reconnect (FpiSdcpDevice *device,
                                    const guchar  *host_reconnect_random,
                                    const guchar  *device_reconnect_mac);

gboolean fpi_sdcp_verify_authorized_identity (FpiSdcpDevice *device,
                                              const guchar  *host_identify_nonce,
                                              const guchar  *device_enrollment_id,
                                              const guchar  *device_identify_mac);

guchar *fpi_sdcp_generate_random (void);

guchar *fpi_sdcp_generate_enrollment_id (FpiSdcpDevice *device,
                                         const guchar  *device_nonce);

int fpi_sdcp_get_cert_length_from_buf (const guchar *buf);

void fpi_sdcp_connect_response_free (FpiSdcpConnectResponse *connect_response);
G_DEFINE_AUTOPTR_CLEANUP_FUNC (FpiSdcpConnectResponse, fpi_sdcp_connect_response_free)

G_END_DECLS
